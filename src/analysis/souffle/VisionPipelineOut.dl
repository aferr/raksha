
#ifndef SRC_ANALYSIS_SOUFFLE_VISION_PIPELINE_OUT_DL_
#define SRC_ANALYSIS_SOUFFLE_VISION_PIPELINE_OUT_DL_

// This file represents the expected output of converting
// //third_party/arcs/examples/VisionPipeline.arcs into
// datalog (presumably by converting it into protos in between)

#include "taint.dl"
#include "flat_graph_ir.dl"
#include "VisionPipelineTagOwners.dl"
#include "VisionPipelineAuthLogicOutput.dl"

// Particle 1: ImageDetector
bindFlatParticle("ImageDetector", $FlatParticle(
    /* reads */
    $Cons("sensor_data_packet.camera_feed",
        $Cons("sensor_data_packet.video_resolution",
        $Cons("image_detection_model", $Nil()))),
    /* writes */
    $Cons("image_detection_boxes", $Nil())
)).

claimHasTag("sensor_data_packet.camera_feed", "raw_video_tag").
claimHasTag("user_selection_action", "user_selection_tag").
claimHasTag("detection_model", "image_detection_model_tag").

// Particle 2: ImageSelector
bindFlatParticle("ImageSelector", $FlatParticle(
    /* reads */
    $Cons("image_detection_boxes", $Cons("user_selection_action", $Nil())),
    /* writes */
    $Cons("selected_image_id", $Nil())
)).

claimHasTag("image_detection_boxes", "detected_images_tag").
claimHasTag("selected_image_id", "product_id_tag").

// (* It's also possible to skip the "bindFlatParticle" part (defined in
// flat_graph_ir) and directly define the "edge" relations that will be 
// produced by the "bindFlatParticles(...)" + flat_graph_ir *)

//-----------------------------------------------------------------------------
//The part below this line is generated by:
// "check is_selected_image_id is product_id_tag"
// (Probably part of this code should actually be in our "analysis" rather than
// generated here)

// "dummy_check_path_product_id_tag" is not a real path. It is just needed
// to do this check because we use paths both as paths through graphs and as 
// labels (which are sets of tags).
claimHasTag("dummy_check_selected_image_id", "product_id_tag").

//------ this part should move into src/analysis/souffle/
// define subset or equals (flowsTo) by finding a counterexample
.decl isNotSubsetOrEquals(p1: AccessPath, p2: AccessPath)
.decl subsetOrEquals(p1: AccessPath, p2: AccessPath)

isNotSubsetOrEquals(p1, p2) :- 
    isAccessPath(p2),
    mayHaveTag(p1, t), !mayHaveTag(p2, t).
subsetOrEquals(p1, p2) :- 
    isAccessPath(p1), isAccessPath(p2),
    !isNotSubsetOrEquals(p1, p2).
// ----------------------------

// NOTE TODO:
// Some other code needs to check that the following can be proved
// to do the "check":
// This "Check" is only true if the label of selected_image_id from 
// DFA + downgrades from authorization logic 
// subsetOrEquals("selected_image_id", "dummy_check_selected_image_id").
// The following souffle-code is a hacky way to do this:

.decl theOneCheck(x: number)
theOneCheck(1) :- subsetOrEquals("selected_image_id", 
    "dummy_check_selected_image_id").
.output theOneCheck

// theOneCheck.csv should have just "1" in it

#endif // SRC_ANALYSIS_VISION_PIPELINE_OUT_DL_
