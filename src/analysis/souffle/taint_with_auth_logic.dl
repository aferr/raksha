//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

// This file gives rules that define a check that does information flow control,
// but uses authorization logic for downgrading.

#include "flat_graph_ir.dl"
#include "auth_logic_interface.dl"
#include "taint.dl"

#ifndef TAINT_WITH_AUTH_LOGIC
#define TAINT_WITH_AUTH_LOGIC

//-----------------------------------------------------------------------------
// Type Declarations
//-----------------------------------------------------------------------------
// An information flow Label which in this model is a set of taint Tags. One 
// label L1 flows to another L2 if L1 is a subset or equal to L2.
.type IFCLabel <: symbol

//-----------------------------------------------------------------------------
// Relation Declarations
//-----------------------------------------------------------------------------
// This party is the owner of a taint Tag (they have the privilege to downgrade
// it).
.decl ownsTag(owner: Principal, tag: Tag)

// Some accessPath is actually downgraded (by taking into consideration the
// privileges of a party trying to downgrade it, and as a result of that party
// deciding to downgrade it). Because here IFC labels are sets of tags (ordered
// by the subset or equals relation), the downgrade works by removing a tag
// from the set (making it "lower" in the order).
.decl downgrades(path: AccessPath, tag: Tag)

// A Tag is a member of the IFCLabel ell (which is a set of Tags).
.decl isMember(tag: Tag, ell: IFCLabel)

// The IFCLabel of an accessPath flowsTo another IFCLabel.
// This is equivalent to "subset or equals". The final outputs (i.e. egress
// points) can be checked by doing a "accessPathIFCLabelFlowsTo" check to a
// particular expected IFCLabel.
.decl accessPathLabelFlowsTo(path: AccessPath, ell: IFCLabel)

// Because datalog does not have universal quantifiers, accessPathLabelFlowsTo 
// (which is "subset or equal to") is defined by proving that there is no 
// counterexample to the subset relation. A counterexample to the relation 
// `isSubsetOrEqual(Set1, Set2)` is an element that is in Set1 but not Set2. 
// The relation `accessPathLabelDoesNotFlowTo` is true when there is a
// counterexample, and accessPathLabelFlowsTo is just the negation of
// accessPathLabelDoesNotFlowTo.
.decl accessPathLabelDoesNotFlowTo(path: AccessPath, ell: IFCLabel)

// This is a variation on the `mayHaveTag` relation defined in `taint.dl`
// It says that an accessPath may have been tainted with tag. By contrast to 
// the other implementation, this one takes into account downgrades (which 
// remove tags). Downgrades happen as a result of statements made in 
// authorization logic.
.decl mayHaveTagAL(accessPath: AccessPath, tag: Tag)

//-----------------------------------------------------------------------------
// Universe Relations
//-----------------------------------------------------------------------------
// These relations say that some object is a member of the universe for that
// object. These are useful for scoping when there is negation or otherwise to 
// ensure that variables are grounded.
.decl isIFCLabel(ell: IFCLabel)

//-----------------------------------------------------------------------------
// Rules
//-----------------------------------------------------------------------------
downgrades(path, tag) :- ownsTag(owner, tag), saysDowngrades(owner, path, tag).

// The following definition of mayHaveTagAL would not work, because when a tag 
// is downgraded from an accessPath it should also not propagate to other paths 
// that are after it in the graph. The following incorrect implementation does 
// not have that behavior
// mayHaveTagAL(path, tag) :- mayHaveTag(path, tag), !downgrades(path, tag).

// Real implementation of mayHaveTagAL

mayHaveTagAL(tgt, tag) :- claimHasTag(tgt, tag).
mayHaveTagAL(tgt, tag) :-
    edge(src, tgt), mayHaveTagAL(src, tag), 
    !downgrades(tgt, tag).

accessPathLabelDoesNotFlowTo(path, ell) :-
    isTag(tag), isIFCLabel(ell), isAccessPath(path),
    mayHaveTagAL(path, tag),
    !isMember(tag, ell).

accessPathLabelFlowsTo(path, ell) :- 
    isIFCLabel(ell), isAccessPath(path),
    !accessPathLabelDoesNotFlowTo(path, ell).

//-----------------------------------------------------------------------------
// Universe Populating Rules
//-----------------------------------------------------------------------------
// These rules add objects to the set of things that exist (i.e. relations like
// `isObject(..)`) whenever they are mentioned in other rules
isIFCLabel(ell) :- isMember(_, ell).

isTag(tag) :- ownsTag(_, tag).
isTag(tag) :- saysDowngrades(_, _, tag).

isAccessPath(path) :- mayHaveTagAL(path, _).

#endif // TAINT_WITH_AUTH_LOGIC

