//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

// This file gives rules that define a check that does information flow control,
// but uses authorization logic for downgrading.

#include "flat_graph_ir.dl"
#include "auth_logic_interface.dl"

#ifndef TAINT_WITH_AUTH_LOGIC
#define TAINT_WITH_AUTH_LOGIC

//-----------------------------------------------------------------------------
// Type Declarations
//-----------------------------------------------------------------------------
// A taint Tag, such as "video_data"
.type Tag <: symbol

// An information flow Label which in this model is a set of taint Tags
.type Label <: symbol

//-----------------------------------------------------------------------------
// Predicate Declarations
//-----------------------------------------------------------------------------
// There is a claim that `accessPath` definitely has `tag` taint.
.decl claimHasTag(accessPath: AccessPath, tag: Tag)

// The Label of a accesPath has a Tag according to the taint analysis
// NOTE: In practice there may be value in explicitly having a layer of
// indirection in which accessPaths have Labels and just Labels have Tags.
// In this formalization, accessPaths also act as Labels (in the sense that they
// have Tags).
.decl mayHaveTag(p: AccessPath, t: Tag)

// This party is the owner of a taint Tag (they have the privilege to downgrade
// it).
.decl ownsTag(owner: Principal, t: Tag)

// Some accessPath is actually downgraded (by taking into consideration the 
// privileges of a party trying to downgrade it)
.decl downgrades(p: AccessPath, t: Tag)

// A Tag is a member of the Label ell (which is a set of Tags).
.decl isMember(t: Tag, ell: Label)

// The Label of an accessPath does not flowTo another Label
// This is equivalent to "not (subset or equals)"
.decl notFieldLabelFlowsTo(p: AccessPath, ell: Label)

// The Label of an accessPath flowsTo another Label.
// This is equivalent to "subset or equals". The final outputs (i.e. egress
// points) can be checked by doing a "accessPathLabelFlowsTo" check to a
// particular expected Label.
.decl accessPathLabelFlowsTo(p: AccessPath, ell: Label)

//-----------------------------------------------------------------------------
// Universe Predicates
//-----------------------------------------------------------------------------
// These predicates say that some object is a member of the universe for that
// object.
.decl isTag(t: Tag)
.decl isLabel(ell: Label)

//-----------------------------------------------------------------------------
// Rules
//-----------------------------------------------------------------------------

downgrades(p, t) :- ownsTag(o, t), saysDowngrades(o, p, t).

mayHaveTag(p, t) :- claimHasTag(p, t).
mayHaveTag(p, t) :- 
    isFlatParticle($FlatParticle(inputs, outputs)),
    accessPathListContains(inputs, p1),
    accessPathListContains(outputs, p),
    mayHaveTag(p1, t), !downgrades(p, t).

notFieldLabelFlowsTo(p, ell) :-
    isTag(t), isLabel(ell), isAccessPath(p),
    mayHaveTag(p, t),
    !isMember(t, ell).

accessPathLabelFlowsTo(p, ell) :- 
    isLabel(ell), isAccessPath(p),
    !notFieldLabelFlowsTo(p, ell).

//-----------------------------------------------------------------------------
// Universe Populating Rules
//-----------------------------------------------------------------------------
// These rules add objects to the set of things that exist (i.e. predicates like
// `isObject(..)`) whenever they are mentioned in other rules
isLabel(ell) :- isMember(_, ell).

isTag(t) :- claimHasTag(_, t).
isTag(t) :- isMember(t, _).
isTag(t) :- ownsTag(_, t).
isTag(t) :- saysDowngrades(_, _, t).

isAccessPath(a) :- claimHasTag(a, _).
isAccessPath(a) :- mayHaveTag(a, _).

#endif // TAINT_WITH_AUTH_LOGIC